太有趣了 第一个problem1的程序无论如何 跑出来都是0.000
我觉得是哪里写错了
我觉得是哪里写错了
我觉得是哪里写错了
我觉得是哪里写错了？
在0.1为单位的扫描中表现正常 为什么二分就炸了 哭



# Day1
下午18点开开心心地打开了今年的竞赛题，组队的同学说我们就在A、B中选一个吧（为什么不做C呢？因为怕做的人太多）。拿着题目开开心心去和饭搭子一起讨论讨论~~疯狂疯狂星期四~~。研究一下，还是准备搞一下A题（B题看着光学不太好下手）。于是就开始了激情的讨论。首先考虑如何判断导弹是否可以看到真目标。首先，最基础的就是判断圆心到空间几何体的距离。我提出可以通过延长圆柱求焦点的$y_max$和$y_min$来判断，计算过于复杂，遂放弃。qzk提出可以俯视做切线来判断，并且我补充了侧视部分的判断。最后的最后，我们选择在圆柱的表面上取大量的点，判断是否能看见来大概地判断。我将我之前写的python项目文件结构抄了过来，于是就有了将所有输出导到log文件的功能~~特性~~。开始为题目中的每个对象建立类，并导入参数，写了两种时间变化方式（一个是更新在自身，一个是更新到新的Object中）。之后开始写`Checker.py`，用于保存所有的check函数。写了一个简单的`test.py`测试了一下检查是否可见。最后开始写飞行器，当时以为飞行器是只能投一个烟雾弹，所以想判断$(x,y,z)$的烟雾弹是否能在$t$时间飞到，委托给了hll就去跑了会儿步。结果回来突然想到，不止能扔一个，于是骂骂咧咧撤回了委托，给飞行器单独写了不同飞法的计算函数，明确了不同情况下要修改的参数。然后开始写`Problem1.py` 采用了模拟退火。刚开始忘记搜到break了，直接就炸开。后来没有约束$0\le direction\le 2\pi$，数值直接起飞。后来是找到了一个符合的值，左右二分找左边界和右边界，结果$L=R$，笑死了，开始debug。简单输出一下$step=0.1$查找到的合理的值，都是有的。做到这里已经是Day2的早上4:30了，于是洗洗睡了。

# Day2
早上先康了一眼选课，然后中午饭吃完开始debug，发现`Problem1.py`中missile1为全局，被多次更新，遂找到错误。算出时间约为4.14s，与网上的大多数答案不符。在之后加强了`Checker.py`中对于导弹在烟雾弹中和真目标在烟雾弹中的判断。并且做出了0.05s左右的有趣结果。突然和队友聊天发现第一题是确定方向的，而我写了模拟退火寻找最佳方向求最优解，笑死了。小改一手后时间还是不对。队友设置了一个宽条件发现结果比较接近网络答案，遂开始找判断的bug。结果发现AI生成的AM式子写错了，没发现，太有乐子了，改正后时间恢复正常。下午打了几把三角洲，把第三题暂时交给了hll，准备开始肝第四题。第四题采用了群体算法，将所有的参数放到一个12维的空间中集体求解，先是尝试了严格让每个初始点都满足有覆盖，结果发现结果过于严苛，于是想着用10%的满足覆盖的点带动其他散点求解。运行时发现速度实在是有点慢了，于是单开文件写了一个分发包来实现并发的版本，很好GPU都跑满了，但大概还是要跑半个多小时，答案甚至不如Problem2得出的答案（直觉表示 Problem4的答案严格大于Problem2）, 观察log日志后发现$FY1、FY2、FY3$的遮盖时间似乎是分开独立（可能有交叉）的，便思考采用基因变换的方式让不同飞机的最佳参数互相迁移。（思考），那是不是可以将每个飞机都单独求解，最后累加。于是便有了最后的方法，将Problem2的代码进行细微修改后根据三个飞机不同的参数得到了最后的结果，大概是11.5s，下班收工~~

# Day3

由于第四题出色的表现，让我十分怀疑python的速度，于是准备转向C++写线程池，但是系统中似乎缺少了C++运行的一些动态库，于是准备使用Rust。将项目一点点移植到Rust中（我们为了打数模用的语言可真多，语言带师了属于是），但是Rust的熟练度不够，debug时间太长，觉得不如使用Python。最后又使用Python来尝试解决。思考了一下，程序的初始化时间太长了，于是就想着先生成一些点，然后直接拿来用，有的用其中的一个部分。于是写了`gene.py`,尝试多线程，但是感觉不如使用程序多开，于是复制了几份一起跑。